// ЗАДАНИЯ ДЛЯ РАЗМИНКИ!!!!!!)))

// ЗАДАНИЕ №1
// Есть массив cо строк, взять только те у которых есть символы g и a в подстроке, порядок не важен
// РЕШЕНИЕ

const arrayOfStrings = ['qe', 'gdag', 'gga', 'gtrxa', 'hghh', 'ga'];

let substr = "g, a";

let result = [];

for (let i = 0; i < arrayOfStrings.length; i++) {
  let word = arrayOfStrings[i];

  if ( substr.includes( word[word.indexOf("g")] && 
                        word[word.indexOf("a")]) ) {
    result.push(arrayOfStrings[i]);
  }
}

console.log(result);

// ЗАДАНИЕ №2
// Через цикл создать числа фибоначи! То есть на выходе получаем массив с чисел фибоначи, 15 чисел не больше. 
// можно попробовать через рекурсию как эдвансед.
// РЕШЕНИЕ

// Через цикл 
function fibonacci(num) {
  let result = [0, 1];

  for (let i = 2; i <= num; i++) {
    let prevNum1 = result[i - 1];

    let prevNum2 = result[i - 2];
    
    result.push(prevNum1 + prevNum2);
  }
  return result;
}

console.log( fibonacci(15) );

// Через рекурсию
function fibonacci(num) {
  if (num < 2) {
    return num;
  }
  return fibonacci(num - 1) + fibonacci(num - 2);
}

console.log( fibonacci(15) );

// ЗАДАНИЕ №3
// Через рекурсию сумируем все числа в массиве
// РЕШЕНИЕ

function summ(arr, sum) {
  if (arr.length) {
    return summ(arr, sum + arr.pop());
  } 
  return sum;
}

console.log( summ([4, 1, 65, 2, 6, 7, 2, 1, 6], 0) );

// ЗАДАНИЕ №4
// Написать функцию которая принимает 2 параметра from и to, и будет считать сумму  всех нечетных чисел и потом среднее арифметическое от этой суммы!
// Задачу решить 2-мя способами! Цыклами и рекурсией!
// РЕШЕНИЕ

// Через цикл
function func(from, to) {
  let result;

  let arrNumbers = [];

  for (let i = from; i <= to; i++) {
    arrNumbers.push(i);
  }

  let arrOddNumbers = [];

  for (let i = 0; i < arrNumbers.length; i++) {
    if (arrNumbers[i] % 2 != 0) {
      arrOddNumbers.push(arrNumbers[i]);
    }
  }

  let sumArrOddNumbers = 0;

  for (let i = 0; i < arrOddNumbers.length; i++) {
    sumArrOddNumbers += arrOddNumbers[i];
    result = sumArrOddNumbers / arrOddNumbers.length;
  }
  return result;
}

console.log( func(5, 15) );

// Через рекурсию
let arrOddNumbers = [];

let avarage;

function func (from, to) {
  if (from === to) {
    arrOddNumbers.push(to)
    return to;
  }

  if (from % 2 == 0) {
    return func(from + 1, to);
  }

  arrOddNumbers.push(from);

  return from + func(from + 1, to);
}

let sum = func(5, 15);

avarage = sum / arrOddNumbers.length;

console.log(avarage);

// ЗАДАНИЕ №5
// Написать поясниние как будет выполнятся в коллстэке следующий код!
// РЕШЕНИЕ

function a() { 
  return b();
}

function b() { 
  return c();
}

function c() {
  return d();
}
function d() { 
  return 'HELLO';
}

a();

// 1. Вызываем функцию "a();"
// 2. Функция "a();" помещается в очередь call stack

/*
  [a] <---
*/

// 3. Выполняется код внутри функции "a();"
// 4. Вызывается функция "b();"
// 5. Функция "b();" помещается в очередь call stack

  /*
  [b] <---
  [a]
*/

// 6. Выполняется код внутри функции "b();"
// 7. Вызывается функция "с();"
// 8. Функция "с();" помещается в очередь call stack

/*
  [c] <---
  [b] 
  [a]
*/

// 9. Выполняется код внутри функции "c();"
// 10. Вызывается функция "d();"
// 11. Функция "d();" помещается в очередь call stack

/*
  [d] <---
  [c] 
  [b] 
  [a]
*/

// 12. Выполняется код внутри функции "d();"
// 13. Возврат выполнения кода с места вызова функции "d();"
// и продолжение выполнения оставшегося кода функции"a();"
// 14. Выполненная функция "d();" удаляется из очереди call stack

  /*
    ---> [d]
  [c] 
  [b] 
  [a]
*/

// 15. Тоже происходит и с другими функциями "[c], [b]"
// 16. Когда весь код внутри функции "a();" выполнен, 
// происходит возврат выполнения оставшейся части кода с места её вызова 
// 17. Выполненная функция "a();" удаляется из очереди call stack

/*
  empty
*/

// 18. Получаем "HELLO"

// ЭТА ЧАСТЬ НЕ ОТНОСИТСЯ К ДОМАШКЕ, ТУТ Я ДЛЯ СЕБЯ ПЫТАЛСЯ РАСПИСАТЬ КАК ЭТА ТЕМА РАБОТАЕТ))

// Рекурсия - бесконечный цикл который осуществляется путём вызова функции самой себя,
// чтобы он не был бесконечным, нужно добавить условие остановки
// Информация о процессе выполнения запущенной функции хранится в её контексте выполнения (callstack),
// это специальная внутренняя структура данных, которая содержит информацию о вызове функции, 
// один вызов функции имеет ровно один контекст выполнения, связанный с ним.

function recursive(start, end) {
  if (start === end) {
    return end;
  }
  return start * recursive(start + 1, end);
}

recursive(5, 10);

// 1. Сначала вызываем функцию recursive и передаём ей аргументы 5 и 10 в её параметры start и end 
// 2. if (start === end) - база рекурсии, потому что сразу же приводит к очевидному результату, 
// если будет true то произойдет принудительное завершение функции и возвращение результата
// 3. start * recursive(start + 1, end) - шаг рекурсии, мы сводим задачу к более простому действию, 
// последующие шаги упрощают задачу всё больше и больше, пока start не будет равен end
// 4. пока start не равен end, будет возвращаться start * recursive(start + 1, end)
// 5. сначала получаем 5 * recursive(6, 10), start уже умножается на значение которое вернет функция recursive(start + 1, end),
// пока функция не вернёт значение, операция умножения не будет выполнена (ведь перед тем как умножить нужно подсчитать)
// Контекст выполнения (callstack)

/*
  Контекст №5 ----- 9 * recursive(10, 10) <---| (9 * 10 = 90)
              ^                                             |
  Контекст №4 ----- 8 * recursive(9, 10) <------------------| (90 * 8 = 720)
              ^                                                            |
  Контекст №3 ----- 7 * recursive(8, 10) <---------------------------------| (720 * 7 = 5040)
              ^                                                                             |
  Контекст №2 ----- 6 * recursive(7, 10) <--------------------------------------------------| (5040 * 6 = 30240)
              ^                                                                                                |
  Контекст №1 ----- 5 * recursive(6, 10) <---------------------------------------------------------------------| (30240 * 5 = 151200)
*/

// 6. выполнение текущей функции 5 * recursive(6, 10) приостанавливается
// 7. контекст выполнения, связанный с ней, запоминается в callstack
// 8. выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения
// 9. после их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена
// 10. мы как бы поднимаемя вверх, проходим до конца, получаем промежуточные результаты, затем спускаемя вниз, чтобы получить конечный результат
// Общее количество вложенных вызовов это глубина рекурсии. В нашем случае она будет 5.
// При выполнении recursive(10, 10), в отличие от предыдущих запусков, условие start === end истинно, поэтому выполняется база рекурсии,
// вложенных вызовов больше нет, поэтому функция завершается, возвращая 10;
// Когда функция заканчивается, контекст её выполнения больше не нужен, поэтому он удаляется из памяти, а из стека восстанавливается предыдущий